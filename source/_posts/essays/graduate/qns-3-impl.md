---
title: qns-3 实现
tags:
  - quantum
  - network
categories:
  - paper-reading
  - network
  - routing
index_img: /img/reading.jpg
banner_img: /img/reading.jpg
excerpt: 代码实现
abbrlink: 7a6a7d9a
date: 2026-01-20 00:00:00
---
# 量子网络栈设计文档

## 1. 量子网络分层澄清
### 物理层
模拟光纤上的量子比特、量子门操作、测量和退相干过程。
### 链路层
相邻节点的纠缠生成（合并到物理层）
### 网络层
纠缠交换和量子路由

## 2. 架构设计

```
┌─────────────────────────────────────────────────────────────┐
│                         Applications                        │
│  ┌──────────┐ ┌──────────┐ ┌──────────┐ ┌──────────────┐    │
│  │EntSwapApp│ │ TelepApp │ │DistillApp│ │FourNodeChain │    │
│  └──────────┘ └──────────┘ └──────────┘ └──────────────┘    │
├─────────────────────────────────────────────────────────────┤
│                           Protocols                         │
│  ┌────────────────────┐ ┌─────────────────────────────┐     │
│  │DistributeEPRProto  │ │   QuantumNetStackHelper     │     │
│  └────────────────────┘ └─────────────────────────────┘     │
├─────────────────────────────────────────────────────────────┤
│                    Quantum Physical Layer                   │
│  ┌────────────────┐ ┌─────────────────┐ ┌──────────────┐    │
│  │QuantumPhyEntity│ │QuantumMemModel  │ │QuantumChannel│    │
│  └────────────────┘ └─────────────────┘ └──────────────┘    │
└─────────────────────────────────────────────────────────────┘
```


## 3. 一些量子网络协议实现

### 3.1 EPR分发协议（测试用）

**流程:**
1. 源节点生成Bell态 |Φ+⟩ = (|00⟩ + |11⟩)/√2
2. 应用链路退极化噪声
3. 通过经典信道通知目标节点
4. 目标节点接收量子比特所有权

### 3.2 纠缠交换协议（测试用）

**Bell态测量 (BSM):**
```cpp
// CNOT门 + Hadamard门 + 测量
m_qphyent->ApplyGate("God", "QNS_GATE_CNOT", {}, {qubit2, qubit1});
m_qphyent->ApplyGate("God", "QNS_GATE_H", {}, {qubit1});
auto outcome0 = m_qphyent->Measure(owner, {qubit1});
auto outcome1 = m_qphyent->Measure(owner, {qubit2});
```

**Pauli校正:**
- 测量结果 (m0, m1) 决定校正操作
- X校正: 基于 m1
- Z校正: 基于 m0

### 3.3 Q-CAST 路由协议
#### 3.3.1 协议时隙结构
每个时隙分为四个阶段：
1. **P1（请求分发）**：所有节点通过经典网络获知当前的源-目的对请求集合。
2. **P2（路由计算）**：所有节点同步运行相同的路由算法，为每个请求计算**主路径**和**恢复路径**，并预留无冲突的量子资源（量子比特和信道）。
3. **P3（链路状态交换）**：节点与邻居交换经典消息，获取 $k$ 跳内的量子链路纠缠建立状态（成功/失败）。
4. **P4（恢复与交换）**：节点基于局部链路状态，独立决策并执行纠缠交换。

#### 3.3.2 路由计算：贪婪扩展Dijkstra算法 (G-EDA)
在 P2 阶段，协议使用 G-EDA 算法为请求分配路径。由于期望吞吐量 $E_t$ 是非加性度量（受链路成功率和对数时间交换成功率影响），传统 Dijkstra 无法直接使用。G-EDA 在残存图上寻找帕累托最优路径，并在分配后扣除资源以避免冲突。

**路由计算核心代码:**
```cpp
// 更新全局拓扑信息以支持多跳路由发现
m_routingProtocol->UpdateTopology(fullTopology);

// 使用GEDA算法计算最优路径
// 目标：寻找一条无资源冲突的路径，使得端到端期望吞吐量最大化
auto route = m_routingProtocol->CalculateRoutesGEDA(srcNode, dstNode);
```

#### 3.3.3 局部恢复与纠缠交换调度
在 P4 阶段，节点利用 $k$ 跳内的局部信息，将主路径和恢复路径视为边集，通过计算对称差（异或）来决定连通性。决定参与交换的节点采用**对数时间交换调度**（分治策略），在 $\lceil\log_2(h+1)\rceil$ 轮内完成多跳交换，最小化量子态在存储器中的等待时间。

**多跳交换与保真度评估代码:**
```cpp
// 沿路径依次进行纠缠交换 (简化版线性交换示例)
for (size_t i = 1; i < path.size() - 1; ++i) {
    std::string intermediateNode = path[i];
    
    // 1. 在中间节点执行Bell态测量 (BSM)
    m_qphyent->ApplyGate("God", "QNS_GATE_CNOT", {}, {qubit2, qubit1});
    m_qphyent->ApplyGate("God", "QNS_GATE_H", {}, {qubit1});
    auto m1 = m_qphyent->Measure(intermediateNode, {qubit1});
    auto m2 = m_qphyent->Measure(intermediateNode, {qubit2});
    
    // 2. 根据测量结果对目标节点执行Pauli校正
    if (m2 == 1) m_qphyent->ApplyGate("God", "QNS_GATE_X", {}, {targetQubit});
    if (m1 == 1) m_qphyent->ApplyGate("God", "QNS_GATE_Z", {}, {targetQubit});
}

// 计算最终生成的端到端纠缠态的保真度
double fidelity = m_qphyent->GetFidelity("God", {srcQubit, dstQubit}, "QNS_STATE_BELL_PHI_PLUS");
```


## 4. 仿真结果与分析

### Q-CAST
实验配置：
- **量子存储器退相干模型 (Decoherence Model)**：
  量子态在存储器中随时间推移会发生退相干。仿真中通过 `tCoherence` 参数设置量子存储器的退相干时间（$T_2$ 时间，本例中设为 100 ms）。底层通过 `TimeModel` 追踪量子比特的驻留时间，并在执行量子门或测量操作前，根据驻留时间 $\Delta t$ 自动应用指数衰减的退极化噪声（Error $\propto 1 - e^{-\Delta t / T_2}$），从而真实反映存储时间对最终保真度的影响。
- **经典网络延迟模型 (Delay Model)**：
  纠缠交换（BSM）的测量结果需要通过经典网络传递给目标节点进行 Pauli 校正。仿真中采用了突发延迟模型（`BurstDelayModel`），模拟了经典控制信号在网络中传输的传播延迟和排队延迟。这种经典延迟直接延长了量子比特在存储器中的等待时间，进而触发上述的退相干效应。

主要参数配置如下：

| 参数名称       | 参数值 | 说明                              |
| :------------- | :----- | :-------------------------------- |
| `numRuns`      | 10     | 独立仿真运行次数                  |
| `numNodes`     | 15     | 网络节点总数                      |
| `numRequests`  | 12     | 随机生成的端到端纠缠请求数        |
| `topologyType` | 1      | 拓扑类型 (1 = Erdos-Renyi 随机图) |
| `edgeProb`     | 0.40   | 节点间存在物理链路的概率          |
| `kHop`         | 3      | 路由算法搜索的最大跳数限制        |
| `tCoherence`   | 100 ms | 量子存储器的退相干时间            |


#### 仿真运行结果
|  运行 ID   | 随机种子 | 拓扑边数 | 成功建立路径数 | 路由成功率 (%) | 平均保真度 | 平均吞吐量 | 平均跳数 | 平均总延迟 (ms) |
| :--------: | :------: | :------: | :------------: | :------------: | :--------: | :--------: | :------: | :-------------: |
|     1      |    1     |    46    |       10       |     83.33      |   0.9191   |   0.8358   |   1.80   |       7.2       |
|     2      |    2     |    33    |       11       |     91.67      |   0.9180   |   0.8327   |   1.82   |       7.3       |
|     3      |    3     |    44    |       12       |     100.00     |   0.9376   |   0.8634   |   1.50   |       6.0       |
|     4      |    4     |    49    |       10       |     83.33      |   0.9275   |   0.8723   |   1.50   |       6.0       |
|     5      |    5     |    38    |       10       |     83.33      |   0.9244   |   0.8347   |   1.70   |       6.8       |
|     6      |    6     |    36    |       11       |     91.67      |   0.9249   |   0.8237   |   1.91   |       7.6       |
|     7      |    7     |    45    |       10       |     83.33      |   0.9237   |   0.8446   |   1.70   |       6.8       |
|     8      |    8     |    39    |       11       |     91.67      |   0.9332   |   0.8349   |   1.73   |       6.9       |
|     9      |    9     |    48    |       11       |     91.67      |   0.9365   |   0.8876   |   1.45   |       5.8       |
|     10     |    10    |    55    |       12       |     100.00     |   0.9402   |   0.8864   |   1.33   |       5.3       |
| **平均值** |    -     | **43.3** |    **10.8**    |   **90.00**    | **0.9285** | **0.8516** | **1.64** |    **6.57**     |

在 15 个节点、边生成概率为 0.4 的随机拓扑中，Q-CAST 协议能够以平均 90% 的成功率满足随机生成的 12 个纠缠请求。
